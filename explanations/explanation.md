# readme

## огляд

в цьому завданні ми оптимізували складний sql-запит у три кроки:

1. логічне спрощення: використали cte для зрозумілості коду.
2. індексація: додали індекси, щоб уникнути повних сканувань таблиць.
3. підказки оптимізатора: використали use index, щоб керувати вибором індексів.

для кожної версії порівняли ключові показники з explain analyze.

---

## кроки оптимізації

### крок 0: оригінальний запит

* опис: один великий запит із підзапитами і in-фільтром.
* продуктивність:

  * агрегація і сортування займали приблизно 0.54+0.06 мс.
  * багато повних сканувань таблиць order\_items, orders, users, products.

### крок 1: логічне спрощення

* зміни:

  * розбили на три cte:

    * orders\_with\_large\_items: вибір order\_id де quantity >= 5
    * low\_stock\_count: підрахунок товарів з stock < 10
    * order\_totals: сума (quantity \* price) по кожному order\_id
  * замінили підзапити і in на join-операції та cross join
* чому:

  * cte роблять код чистішим і зручнішим для підтримки
  * рахунок низького запасу виконується лише раз, а не для кожного рядка
* вплив:

  * час агрегації зріс до \~0.8 мс через матеріалізацію cte без індексів
  * код став зрозуміліший, але без індексів продуктивність трохи погіршилась

### крок 2: індексація

* зміни:

  * створили індекси:

    * orders(user\_id, order\_date)
    * order\_items(order\_id, quantity)
    * order\_items(order\_id)
    * orders(order\_id)
    * users(user\_id)
    * products(stock)
* чому:

  * складений індекс на (user\_id, order\_date) прискорює фільтрацію orders
  * покриваючі індекси на order\_items допомагають і для фільтрації, і для join
  * індекс на products(stock) пришвидшує підрахунок low\_stock\_count
  * ключові індекси прискорюють всі join-операції
* вплив:

  * час агрегації впав до \~0.32 мс
  * сортування скоротилося до \~0.37 мс
  * загалом \~40% прискорення порівняно з початковим

### крок 3: підказки оптимізатора

* зміни:

  * додали use index(idx\_order\_items\_order\_id\_quantity) в cte orders\_with\_large\_items
  * додали use index(idx\_products\_stock) в cte low\_stock\_count
* чому:

  * іноді оптимізатор вибирає не найкращий індекс, тому можна вказати явно
* вплив:

  * час агрегації підріс до \~0.51 мс
  * сортування до \~0.55 мс
  * підказки в цьому випадку погіршили план, тому їх слід використовувати обережно

---

## висновки

* cte роблять код зрозумілішим, але можуть матеріалізуватися й уповільнювати запит
* індекси дали найбільше прискорення, прибравши повні сканування
* підказки оптимізатора варто застосовувати тільки якщо статистика і індекси не дають бажаного плану

